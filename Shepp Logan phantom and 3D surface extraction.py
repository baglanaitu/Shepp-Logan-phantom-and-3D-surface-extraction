# -*- coding: utf-8 -*-
"""AR_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H83Pjshg_CjrKbJQqRHQZF-pbY0aCnJv

#**Acquisition and Reconstruction**
###Assignment 2 : Shepp Logan phantom and 3D surface extraction

The goal of this assignment is to to extract surfaces from a pre-segmented phantom image. This phantom is the famous Shepp Logan phantom (https://en.wikipedia.org/wiki/Shepp%E2%80%93Logan_phantom).

The file format of this pre-segmented phantom is PGM3D. This is an extension of the common PGM format.

The header is as follow :

    l0      PGM3D    #keyword to identify the file format

    l1      x y z    #size of the 3D image
    
    l2      max      #maximum greylevel
    
    l3-end  DATA     #x*y*z grey values 
    
The three firsts lines represent the header of the file, and from line 4 to the end are the data, one value by line.

You can find the PGM3D file here : http://dept-info.labri.fr/~desbarat/ARM/shepplogan.pgm3d .

You can also use the code below to install the needed libraries and download the file in the current working directory :
"""

import sys
import subprocess
import pkg_resources

required = {'wget', 'numpy', 'matplotlib', 'plotly', 'nbformat'}
installed = {pkg.key for pkg in pkg_resources.working_set}
missing = required - installed

if missing:
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', *missing], stdout=None)

import wget

wget.download("http://dept-info.labri.fr/~desbarat/ARM/shepplogan.pgm3d")

"""Use the snippet below to import the needed libraries (Numpy for array manipulation, matplotlib for 2D plot and plotly for 3D plot) :"""

import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go

"""### **Performances** (2pts)
For this assignment, two points are dedicated to the performance of your implementation. Avoid using nested for loop as mush as possible, and use Numpy function and broadcast operator when possible.

### **Reading the PGM3D file** (5pts)

Step 1.1. Using the python standard libraries, read the content of the pgm3d file, split it by lines and check that the first one is correct. (1pts)

Step 1.2. Collect the data from the header : Width, height, depth and max value. (1pts)
"""

#downloading the file
pgm_file = wget.download("http://dept-info.labri.fr/~desbarat/ARM/shepplogan.pgm3d")
#open the file and read the header and the width,height, depth of the file

file = open(pgm_file)
header = file.readline()
X, Y, Z = file.readline().split()
V = file.readline()

"""Step 1.3. Put the data values in a 3D numpy array. You should first allocate the array : avoid using append or similar functions, it would be really slow. (1pts)"""

def read_file():

    #downloading the file
    pgm_file = wget.download("http://dept-info.labri.fr/~desbarat/ARM/shepplogan.pgm3d")

    #open the file and read the header and the width,height, depth of the file
    file = open(pgm_file)
    header = file.readline()
    width, height, depth = file.readline().split()
    max_value = file.readline()
    print("width :, height:, depth:", width,height,depth,max_value)

    #read the file in to numpy array
    line1 = file.readlines(0)
    
    #change every line value(string) in to an integer
    for i in range(len(line1)):
        line1[i] = int(line1[i])

    #file in to 3d array
    #file_array = np.zeros((64,64,64))
    file_array = np.array(line1)
    file_array = file_array.reshape(64,64,64)
    return file_array

data = read_file()

"""Step 1.4. Display the middle slice of the volume for all three axis (Coronal, Sagittal, Horizontal) using matplotlib. (2pts)"""

def plot_mesh():

  data = read_file()
  #ploting the middle slice of all the volumes
  plt.figure()
  plt.title("coronal ")
  plt.imshow(data[32,:,:]) #coronal
  plt.figure()
  plt.title("sagital ")
  plt.imshow(data[:,32,:]) #sagital
  plt.figure()
  plt.title("axial ")
  plt.imshow(data[:,:,32]) # axial
  plt.show()

plot_mesh()

"""###**Creating a 3d mesh (8pts)**
You will now transform the 3D array into a surface mesh. A mesh is a collection of polygons (in our case, triangles), composed of vertices and faces.

A common way to store a mesh is to build two arrays. The first one store the vertices position, of size 3-by-N, with N the number of vertices : 

```
<vertex0.x> <vertex0.x> <vertex0.x> <vertex1.y> <vertex1.y> <vertex1.y> <vertex2.x> ...
```

The second one store the faces. Each faces is composed of 3 vertices, represented by their respective index in the vertices list. This array should of integer type.

```
<vertex_id1_face0> <vertex_id2_face0> <vertex_id2_face0> <vertex_id0_face1> ...
```

To transform a voxelized volume into a mesh, you will need to create the surface between each region of different values.
So, for each voxels, check its 6 neighboor, and when one is different, create the face between them (or faces, since a square is composed of two triangle).

Step 2.1. Create an array of vertices, and one of faces, that represent a cube of size 1x1x1. (2pts)

Try to do it yourself without taking the values on the internet, to learn how to do it !

Step 2.2. Start the code below. If your vertices and faces are correct. It should display the cube. You can try to remove some faces and see the result to be sure that you know the position of each faces in the array.
"""

cube_vertices = np.array([
[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]
]).flatten()
cube_faces = np.array([
[0,2,3],[0,1,3],[1,3,7],[1,5,7],[5,7,6],[5,4,6],[4,0,2],[4,6,2],[6,2,3],[6,7,3],[0,1,5],[0,4,5]
]).flatten()

def show_figure(cube_vertices,cube_faces):
  
  fig = go.Figure(data=[
      go.Mesh3d(
          x=cube_vertices[0::3],
          y=cube_vertices[1::3],
          z=cube_vertices[2::3],
          color = 'rgb(120, 120, 120)',
          opacity = 0.3,
          i = cube_faces[0::3],
          j = cube_faces[1::3],
          k = cube_faces[2::3],
          showscale=True
      )
  ])

  fig.show()

show_figure(cube_vertices,cube_faces)

"""Step 2.3. The code below will create a new data array exaclty half the size of the full one. From this point, you will use this array in order to avoid long computations."""

data = read_file()

hata = data[0::2, 0::2, 0::2]
hX = int(X)//2
hY = int(Y)//2
hZ = int(Z)//2
print(data.shape)

"""Step 2.4. Now, iterate over the voxels of hData, and fill 'faces_list' and 'vertices_list' to create the mesh that separate all voxels of different values. 
Tips : each 'border' between two region will be processed twice : you can only check three neighboors instead of six to avoid duplicated faces. (6pts)
"""

def get_vertex(axis, i,j,k):

  if (axis == 1):

    #setting the vertex indexes when there is a diffrence of values in the i dimention
    vertex_0_index =(Z+1) * (Y+1) *(i+1)+65*(j)+k
    vertex_1_index =(Z+1)*(Y+1)*(i+1)+(Z+1)*(j)+k+1
    vertex_2_index = (Z+1)*(Y+1)*(i+1)+(Z+1)*(j+1)+k
    vertex_3_index = (Z+1)*(Y+1)*(i+1)+(Z+1)*(j+1)+k+1

  elif (axis ==2):

    #setting the vertex indexes when there is a diffrence of values in the j dimention
    vertex_0_index =(Z+1)*(Y+1)*(i)+(Z+1)*(j+1)+k
    vertex_1_index =(Z+1)*(Y+1)*(i)+(Z+1)*(j+1)+k+1
    vertex_2_index = (Z+1)*(Y+1)*(i+1)+(Z+1)*(j+1)+k
    vertex_3_index = (Z+1)*(Y+1)*(i+1)+(Z+1)*(j+1)+k+1

  elif (axis == 3):

    #setting the vertex indexes when there is a diffrence of values in the j dimention
    vertex_0_index =(Z+1)*(Y+1)*(i)+(Z+1)*(j)+k+1
    vertex_1_index =(Z+1)*(Y+1)*(i)+(Z+1)*(j+1)+k+1
    vertex_2_index = (Z+1)*(Y+1)*(i+1)+(Z+1)*(j)+k+1
    vertex_3_index = (Z+1)*(Y+1)*(i+1)+(Z+1)*(j+1)+k+1

  vertex_index_list = (vertex_0_index,vertex_1_index,vertex_2_index, vertex_3_index)
  
  return vertex_index_list

def create_mesh():
  
  faces_list = []
  face = []
  vertices_list = []
  count = 0
  #creating the vertices and the faces of the meshs
  for i in range(Z+1):
    for j in range(Y+1):
      for k in range(X+1):

        vertices_list.append([i,j,k])
        
        if i==X or j==Y or k==Z:
          continue

        if i+1 < X and data[i][j][k] != data[i+1][j][k]:

          #faces_list = get_face(1,i,j,k) #getting the face when the there are different values in i dimentsion

          vertex_index = get_vertex(1,i,j,k)

          face.append([vertex_index[0], vertex_index[1], vertex_index[2]])
          face.append([vertex_index[1], vertex_index[2], vertex_index[3]])


        if j+1 < Y and data[i][j][k] != data[i][j+1][k]:
          #faces_list = get_face(2,i,j,k) #getting the face when the there are different values in j dimentsion
          vertex_index = get_vertex(2,i,j,k)

          face.append([vertex_index[0], vertex_index[1], vertex_index[2]])
          face.append([vertex_index[1], vertex_index[2], vertex_index[3]])

        if k+1 < Z and data[i][j][k] != data[i][j][k+1]:
          #faces_list = get_face(3,i,j,k) #getting the face when the there are different values in k dimentsion

          vertex_index = get_vertex(3,i,j,k)

          face.append([vertex_index[0], vertex_index[1], vertex_index[2]])
          face.append([vertex_index[1], vertex_index[2], vertex_index[3]])

  vertices_list = np.array(vertices_list, dtype=np.int32).flatten()
  face = np.array(face, dtype=np.int32).flatten()

  return vertices_list, face

"""Step 2.5. The snippet below will display the result of your faces_list and vertices_list."""

X = int(X)
Y = int(Y)
Z = int(Z)
V = 255

vertices_list , faces_list = create_mesh()
show_figure(vertices_list,faces_list)

"""###**Segmenting the mesh (5pts)**

Step 3.1. Now, do the same thing as before but separate each region into its own mesh. To do so, store the faces and vertices in an array corresponding to the current region value. You will now need to check all neighboor this time. (5pts)
"""

def create_mesh_segmented():

  faces_list =  [ [] for i in range(V+1) ] 
  vertices_list =  []
  count = 0
  #creating the vertices and the faces of the meshs
  for i in range(Z+1):
    for j in range(Y+1):
      for k in range(X+1):
        vertices_list.append([i,j,k])

        if i==X or j==Y or k==Z:
          continue
        

        if i+1 < X and data[i][j][k] != data[i+1][j][k]:

          vertex_index = get_vertex(1,i,j,k)
          
          #adding right faces for the value
          faces_list[data[i][j][k]].append([vertex_index[0], vertex_index[1], vertex_index[2]])
          faces_list[data[i][j][k]].append([vertex_index[1], vertex_index[2], vertex_index[3]])

          #adding left faces for the neighbour value
          faces_list[data[i+1][j][k]].append([vertex_index[0], vertex_index[1], vertex_index[2]])
          faces_list[data[i+1][j][k]].append([vertex_index[1], vertex_index[2], vertex_index[3]])

          #Vertices
          #appending the vertices value of the current value


        if j+1 < Y and data[i][j][k] != data[i][j+1][k]:

          vertex_index = get_vertex(2,i,j,k)

          faces_list[data[i][j][k]].append([vertex_index[0], vertex_index[1], vertex_index[2]])
          faces_list[data[i][j][k]].append([vertex_index[1], vertex_index[2], vertex_index[3]])

          faces_list[data[i][j+1][k]].append([vertex_index[0], vertex_index[1], vertex_index[2]])
          faces_list[data[i][j+1][k]].append([vertex_index[1], vertex_index[2], vertex_index[3]])

        if k+1 < Z and data[i][j][k] != data[i][j][k+1]:

          vertex_index = get_vertex(3,i,j,k)

          faces_list[data[i][j][k]].append([vertex_index[0], vertex_index[1], vertex_index[2]])
          faces_list[data[i][j][k]].append([vertex_index[1], vertex_index[2], vertex_index[3]])

          faces_list[data[i][j][k+1]].append([vertex_index[0], vertex_index[1], vertex_index[2]])
          faces_list[data[i][j][k+1]].append([vertex_index[1], vertex_index[2], vertex_index[3]])

             

  for i in range(V+1):
   
    faces_list[i] = np.array(faces_list[i], dtype=np.int32).flatten()
  vertices_list = np.array(vertices_list, dtype=np.int32).flatten()

  return vertices_list, faces_list

vertices_list, faces_list = create_mesh_segmented()

"""Step 3.2. The code below will display each mesh in your lists"""

for i in np.unique(data):
#for j in range(2):
  fig = go.Figure(data=[
      go.Mesh3d(
          
          x=vertices_list[0::3],
          y=vertices_list[1::3],
          z=vertices_list[2::3],
          color = 'rgb(120, 120, 120)',
          opacity = 0.3,
          i = faces_list[i][0::3],
          j = faces_list[i][1::3],
          k = faces_list[i][2::3],
          showscale=True
      )
  ])
  
  fig.show()

"""###**Exporting an OBJ file (bonus)**

4.2. The OBJ file format allow to describe a 3D mesh from a list of vertices and how they are linked to create faces.

It's an ASCII file format that can be resumed as such :

    #List of all vertices

    v x1 y1 z1

    v x2 y2 z2

    v x3 y3 z3

    #List of all faces

    f 1 2 3

This create 3 vertices that are linked together to create one face.

Step 1. Write the code necessary to create an OBJ file that contains a mesh from the previous section You can vizualize your OBJ file using meshlab : https://www.meshlab.net/ (already installed on CREMI machines)
"""

